---
title: 'Übung 06: Quanten Isingmodell'
author: "Tobias Blesgen und Leonardo Thome"
date: "21.07.2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes: 
 - \usepackage{amssymb}
 - \usepackage{amsmath}
 - \usepackage[ngerman]{babel}
 - \usepackage{physics}
 - \bibliographystyle{unsrtnat}
---

[//]: # Ausführbefehl im allgemeinen: ``render("ComputerPhysik06.Rmd")``

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Einführung

\begin{equation}
  H = \sum^{N-2}_{i=0} \sigma_i^x \otimes \sigma^x_{i+1} + g \sum_{i=0}^{N-1} \sigma^z_i
\end{equation}

$\bra{\Psi}\ket{\Psi}$ $\expval{A}{\Psi}$

# Implementation des numerischen Verfahrens



```{Rcpp}
#include<Rcpp.h>
#include<vector>
#include<algorithm>
#include<math.h>  
#include <random>
#include <iostream>

using namespace Rcpp;
using namespace std;

// Berechnungsschritt des Skalierungsvektors: m = 0, pos = 0, dim(vektor) = n
void Hg_Rekursiv(const int n, int m, int l, int pos, std::vector<double>& vektor){
  vektor[pos] = (double)(n - l);
  for (int i = m; i < n; i++){
    Hg_Rekursiv(n, (i + 1), l+2 , pos + pow(2,i), vektor);
  }
}

// Skalierungsvektor (rechtes H)
std::vector<double> g_Vektor(const int n){
  std::vector<double> vektor(pow(2,n));
  Hg_Rekursiv(n, 0, 0 , 0, vektor);
  return vektor;
}

// Normierungsbestimmung
double v_Norm(vector<double> const& u) {
    double sum = 0.;
    for (int i = 0; i < u.size(); ++i) {
        sum += u[i] * u[i];
    }
    return sqrt(sum);
}

// Zufälliger Startvektor
//[[Rcpp::export]]
std::vector<double> random_V(const int l){
  std::vector<double> vektor(l);
  random_device rd; 
  mt19937 gen(rd()); 
  uniform_real_distribution<> dis(0,1.0);
  for (int i = 0; i < l; ++i) {
    vektor[i] = dis(gen);
  }
  double norm = v_Norm(vektor);
  for (int i = 0; i < l; i++){
    vektor[i] /= norm;
  }
  return vektor;
}

//[[Rcpp::export]]
std::vector<double> H(std::vector<double> vektor, std::vector<double> gv, const double g, const int n){
  int size = pow(2,n);
  std::vector<double> neu(size);
  for (int i = 0; i < size; i++){
    neu[i] = gv[i]*g*vektor[i];
  }
  for (int i = 0; i < n-1; i++){
    for (int j = 0; j < 4; j++){
      neu[i*4+j] += vektor[(i+1)*4-j-1];
    }
  }
  for (int i = 0; i < (n-2); i++){
    int mittel = pow(2,n-i-2);
    for (int grob = 0; grob < pow(2,i); grob++){
      for (int medium = 0; medium < 4; medium++){
        for (int j = 0; j < pow(2,n-i-2); j++){
          neu[(grob*4+medium)*mittel+j] += vektor[j+(4*(grob+1)-medium)*mittel-2];
          //Rprintf("i=%d j=%d: %d; %d \n", i, j, (grob*4+medium)*mittel+j, j+(4*(grob+1)-medium)*mittel-2);
        }
      }
    }
  }
  return neu;
}

// Hauptfunktion zur Eigenwertbestimmung
std::vector<double> eigen(const int n, const int g){
  const int l = pow(2,n);
  std::vector<double> vektor(l);
  std::vector<double> g_vektor = g_Vektor(n);
  return vektor;
}


```



## Stabilitätsüberprüfung

```{r}
a = random_V(3)
a
```


Wir wollen am Beispiel des $\gamma = 0$ Falls überprüfen, ob unsere Methodik stabil ist. Wir würden erwarten, dass die mittlere Amplitude über die Zeit konstant bleibt, und tragen hierzu die Summe aller Funktionspunkte grafisch gegen die Zeit auf:

```{r, echo=FALSE, fig.cap="\\label{fig:stabilitaet} Stabilität bei keiner Abschwächung", fig.width=7,fig.height=4}
a1 = c(1,0,0,0,0,0,0,0)
g = g_Vektor(3)
b1 = H(a1, g, 0.02, 3)
g
a1
b1

```

```{r, echo=FALSE, fig.cap="\\label{fig:stabilitaet} Stabilität bei keiner Abschwächung", fig.width=7,fig.height=4}
a1 = c(1,0,0,0)
a2 = c(0,1,0,0)
a3 = c(0,0,1,0)
a4 = c(0,0,0,1)
g = g_Vektor(2)
b1 = H(a1, g, 0.02, 2)
b2 = H(a2, g, 0.02, 2)
b3 = H(a3, g, 0.02, 2)
b4 = H(a4, g, 0.02, 2)
g
a1
b1
a2
b2
a3
b3
a4
b4
```

Wie wir sehen können, bleibt die Amplitudensumme über dem betrachteten Bereich sehr konstant und wir können die Methode im Folgenden auf ein gedämpftes System anwenden.


# Fazit
Durch das Umformen der DGL zur Gleichung \ref{Punktformel} ließ sich der zeitliche Schwingungsverlauf örtlich bestimmen.


\begin{thebibliography}{99}
\bibitem{demtroeder} 
Wolfgang Demtröder, \textit{Experimentalphysik 1, Mechanik und Wärme}, SpringerSpektrum, Auflage 8, 2018, Seite 334.

\end{thebibliography}
