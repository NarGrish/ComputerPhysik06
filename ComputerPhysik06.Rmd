---
title: 'Übung 06: Quanten Isingmodell'
author: "Tobias Blesgen und Leonardo Thome"
date: "21.07.2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes: 
 - \usepackage{amssymb}
 - \usepackage{amsmath}
 - \usepackage[ngerman]{babel}
 - \usepackage{physics}
 - \bibliographystyle{unsrtnat}
---

[//]: # Ausführbefehl im allgemeinen: ``render("ComputerPhysik06.Rmd")``

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Einführung

Das Isingmodell beschreibt die Gitterinteraktionen für Wellenausbreitungen. Um die Ausbreitung einer transversalen Welle auf einem eindimensionalen Gitter zu beobachten, schreiben wir den Hamilton-Operator der $N$ Gitterpunkte als:

\begin{equation}
  H = \sum^{N-2}_{i=0} \sigma_i^x \otimes \sigma^x_{i+1} + g \sum_{i=0}^{N-1} \sigma^z_i.
\end{equation}

Wir werden ihn, auf Zuständen basierend auf der Basis des Tensorprodukts aller Einspin-Zustände ($\ket{00..00}$ bis $\ket{11..11}$), anwenden, um ihn auf seine Grundzustandsenergie und -wellenfunktion, zu untersuchen. Das $g$ stellt hierbei die Kopplung an ein externes Feld.

Anschließend werden wir für $g=1$ den Phasenübergang für die Magnetisierung 

\begin{equation}
  M = \frac{1}{N} \bra{\psi} \sum_{i=0}^{N-1} \sigma_i^z \ket{\psi}
\end{equation}

betrachten.

# Implementation des numerischen Verfahrens

Der Hamiltonoperator in Matrixschreib weise wächst mit $2^{2N}$. Da wir bis zu $N=10$ Gitterpunkte betrachten wollen würde eine Implementation in Form von Matrixmultiplikationen eine zeitlich sehr aufwendige Anwendung werden. Da die Matrix mit $((N-1)2^N)_{H_0} + (2^N)_{H_1}$ besetzten Elementen recht schwach besetzt ist haben wir uns entschieden den Hamiltonoperator explizit als Funktion zu implementieren. So wird in einem \texttt{for}-Schleifen-System der Eingangsvektor $v$ in der Funktion \texttt{H}, mit dem zuvor für die Anzahl $N$ erzeugten \texttt{g_vektor}, zu $Hv$ überführt


```{Rcpp}
#include<Rcpp.h>
#include<vector>
#include<algorithm>
#include<math.h>  
#include<iostream>
#include<random>
#include <stdio.h>
#include <stdlib.h>
#include<time.h>

using namespace Rcpp;
using namespace std;

// Berechnungsschritt des Skalierungsvektors: m = 0, pos = 0, dim(vektor) = n
void Hg_Rekursiv(const int n, int m, int l, int pos, std::vector<double>& vektor){
  vektor[pos] = (double)(n - l);
  for (int i = m; i < n; i++){
    Hg_Rekursiv(n, (i + 1), l+2 , pos + pow(2,i), vektor);
  }
}

// Skalierungsvektor (rechtes H)
std::vector<double> g_Vektor(const int n){
  std::vector<double> vektor(pow(2,n));
  Hg_Rekursiv(n, 0, 0 , 0, vektor);
  return vektor;
}

// Normierungsbestimmung
double v_Norm(vector<double> const& u) {
    double sum = 0.;
    for (int i = 0; i < u.size(); ++i) {
        sum += u[i] * u[i];
    }
    return sqrt(sum);
}

// Zufälliger Startvektor
std::vector<double> random_V(const int l){
  std::vector<double> vektor(l);
  srand((time(NULL)));
  //random_device rd; 
  //mt19937 gen(rd()); 
  //uniform_real_distribution<> dis(0.,1.);
  for (int i = 0; i < l; ++i) {
    //vektor[i] = dis(gen);
    vektor[i] = rand() % 100;
  }
  double norm = v_Norm(vektor);
  for (int i = 0; i < l; i++){
    vektor[i] /= norm;
  }
  
  return vektor;
}

// Anwendung von H
std::vector<double> H(std::vector<double> vektor, std::vector<double> gv, const double g, const int n){
  int size = pow(2,n);
  std::vector<double> neu(size);
  for (int i = 0; i < size; i++){
    neu[i] = gv[i]*g*vektor[i];
  }
  for (int i = 0; i < pow(2,n-2); i++){
    for (int j = 0; j < 4; j++){
      neu[i*4+j] += vektor[(i+1)*4-j-1];
      //Rprintf("- %d -\n",(i+1)*4-j-1 );
    }
  }
  for (int i = 0; i < (n-2); i++){
    int mittel = pow(2,n-i-2);
    for (int grob = 0; grob < pow(2,i); grob++){
      for (int medium = 0; medium < 4; medium++){
        for (int j = 0; j < pow(2,n-i-2); j++){
          neu[(grob*4+medium)*mittel+j] += vektor[j+(4*(grob)+3-medium)*mittel];
          //Rprintf("i=%d j=%d: %d; %d \n", i, j, (grob*4+medium)*mittel+j, j+(4*(grob)+3-medium)*mittel);
        }
      }
    }
  }
  return neu;
}

// Hauptfunktion zur Eigenwertbestimmung
//[[Rcpp::export]]
std::vector<double> eigene(const int n, const double g, const int max){
  const int l = pow(2,n);
  std::vector<double> vektor = random_V(l);
  std::vector<double> g_vektor = g_Vektor(n);
  double norm;
  
  for(int i=0; i<max; i++){
    vektor = H(vektor, g_vektor, g, n);
    norm = v_Norm(vektor);
    for (int j = 0; j < l; j++){
      vektor[j] /= norm;
    }
  }
  return vektor;
}

//[[Rcpp::export]]
double eigenwert(std::vector<double> eigenvektor, const double g, const int n){
  const int l = pow(2,n);
  std::vector<double> g_vektor = g_Vektor(n);
  std::vector<double> h_vektor = H(eigenvektor, g_vektor, g, n);
  double norm = v_Norm(eigenvektor);
  double sum = 0.;
  for(int j=0;j<l;j++){
      sum += eigenvektor[j]*h_vektor[j];
    }
  sum /= (norm*norm);
  return sum;
}  

// Matrixausgabe
//[[Rcpp::export]]
void matrixausgabe(const int n, const double g){
  int l = pow(2,n);
  std::vector<double> vektor(l);
  std::vector<double> g_vektor = g_Vektor(n);
  for (int i = 0; i<l; i++){
    for (int j = 0; j<l; j++){
      vektor[j] = 0;
    }
    vektor[i] = 1;
    vektor = H(vektor, g_vektor, g, n);
    for (int j = 0; j<l; j++){
      Rprintf("%d ", (int)(vektor[j]));
    }
    //Rprintf("\n");
  }
  //Rprintf("\n");
}

// Matrix weitergabe
//[[Rcpp::export]]
std::vector<double> matrix1(const int n, const double g){
  int l = pow(2,n);
  std::vector<double> vektor(l);
  std::vector<double> Matrix(l*l);
  std::vector<double> g_vektor = g_Vektor(n);
  for (int i = 0; i<l; i++){
    for (int j = 0; j<l; j++){
      vektor[j] = 0;
    }
    vektor[i] = 1;
    vektor = H(vektor, g_vektor, g, n);
    for (int j = 0; j<l; j++){
      Matrix[l*i+j] = vektor[j];
    }
  }
  return Matrix;
}

// Matrix weitergabe Magneton
//[[Rcpp::export]]
std::vector<double> matrix2(const int n){
  int l = pow(2,n);
  std::vector<double> vektor(l);
  std::vector<double> Matrix(l*l);
  std::vector<double> g_neu_vektor = g_Vektor(n);
  
  
  for (int i = 0; i<l; i++){
    for (int j = 0; j<l; j++){
      Matrix[l*i+j] = 0;
      if(i == j){
        Matrix[l*i+j] = g_neu_vektor[i];
      }
    }
  }
  return Matrix;
}


// Anwendung von H2
std::vector<double> h_shift(std::vector<double> vektor, const double g, const int n, std::vector<double> eigenvektor){
  std::vector<double> g_vektor = g_Vektor(n);
  std::vector<double> h_vektor = H(vektor, g_vektor, g, n);
  const int l = pow(2,n);
  std::vector<double> neu(l);
  const double eigenw = eigenwert(eigenvektor, g, n);
  for (int i = 0; i < l; i++){
    neu[i] = h_vektor[i];
    for (int j = 0; j < l; j++){
      neu[i] -= (eigenw*eigenvektor[i]*eigenvektor[j]); 
    }
  }
  return neu;
}

// erogn
//[[Rcpp::export]]
std::vector<double> wellenfunktion(const int n, const double g, const int max){
  // bestimmung des größten eigenwert-vektors
  std::vector<double> grosser_vektor = eigene(n, g, max);
  // bestimmung des kleinstenm eigenwert-vektors
  const int l = pow(2,n);
  std::vector<double> vektor = random_V(l);
  std::vector<double> g_vektor = g_Vektor(n);
  double norm;
  for(int i=0; i<max; i++){
    vektor = h_shift(vektor, g, n, grosser_vektor);
    norm = v_Norm(vektor);
    for (int j = 0; j < l; j++){
      vektor[j] /= norm;
    }
  }
  return vektor;
}

```



## Stabilitätsüberprüfung



```{r}
#Test

ca = 2:10
a = 2:10
d = 1:10

for (element in ca){
  b = eigene(element, 0, 1001)
  a[element-1] = eigenwert(b, 0,  element)
}
plot((2:10),a,"l")

for (color in d){
  for (element in ca){
    b = eigene(element, color/5, 1000)
    k = eigenwert(b, color/5,element)
    a[element-1] = k
  }
  lines((2:10),a,"l", col=rainbow(10)[color])
}


k =  eigene(2, 1, 10000)
eigenwert(k, 1, 2)
h =  wellenfunktion(2, 1, 10000)
eigenwert(h, 1, 2)

n = 2
A <- matrix(matrix1(n,1), nrow = n^2, ncol = n^2)
ew <-eigen(A)
min(unlist(ew[1]))
```
```{r}
#Eigenwerte mit r für Energie g Kopplung


g = 1
k = 2
ew <- eigen(matrix(matrix1(k,g), nrow = k^2, ncol = k^2))
min(unlist(ew[1]))


n <- c(2,4,6,8,10)
g <- seq(0,2, length.out= 10)
a <- rep(0,length(g))

plot(0,0,ylim =c(0,-20),xlim = c(0,2),"n")


for (N in n){
  i = 1
  for (G in g){
    ew <- eigen(matrix(matrix1(N,G), nrow = 2^N, ncol = 2^N))
    a[i] = min(unlist(ew[1]))
    i = i+1
  }
  lines(g,a,"l", col=rainbow(length(g))[N])
}
```
```{r}
#Eigenwerte mit r für Energie g Kopplung


g = 1
k = 2
ew <- eigen(matrix(matrix1(k,g), nrow = k^2, ncol = k^2))

ew <- eigen(matrix(matrix1(k,g), nrow = 2^k, ncol = 2^k))
ev <- ew$vectors[,which.min(unlist(ew$values))]
ek <- drop(t(ev) %*% (ew$vectors %*% ev))

n <- c(2,4,6,8,10)
g <- seq(0,2, length.out= 10)
a <- rep(0,length(g))

plot(0,0,ylim =c(0,1),xlim = c(0,2),"n")


for (N in n){
  i = 1
  for (G in g){
    ew <- eigen(matrix(matrix1(N,G), nrow = 2^N, ncol = 2^N))
    ev <- ew$vectors[,which.min(unlist(ew$values))]
    a[i] <- -1/N*(drop(t(ev) %*% (matrix(matrix2(N), nrow = 2^N, ncol = 2^N) %*% ev)))
    i = i+1
  }
  lines(g,a,"l", col=rainbow(length(g))[N])
}
```

Wir wollen am Beispiel des $\gamma = 0$ Falls überprüfen, ob unsere Methodik stabil ist. Wir würden erwarten, dass die mittlere Amplitude über die Zeit konstant bleibt, und tragen hierzu die Summe aller Funktionspunkte grafisch gegen die Zeit auf:


Wie wir sehen können, bleibt die Amplitudensumme über dem betrachteten Bereich sehr konstant und wir können die Methode im Folgenden auf ein gedämpftes System anwenden.


# Fazit
Durch das Umformen der DGL zur Gleichung \ref{Punktformel} ließ sich der zeitliche Schwingungsverlauf örtlich bestimmen.


\begin{thebibliography}{99}
\bibitem{demtroeder} 
Wolfgang Demtröder, \textit{Experimentalphysik 1, Mechanik und Wärme}, SpringerSpektrum, Auflage 8, 2018, Seite 334.

\end{thebibliography}
